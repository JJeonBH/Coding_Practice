<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <!-- 뷰포트 지정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSS 요약</title>
    <style>
      body {
        /*
        글꼴 적용
        font-family: '맑은 고딕', 돋움, 굴림;
        */

        /*
        글자 크기
        font-size: 16px;
        CSS에서는 키워드(xx-small, x-small, small, medium, ...)보다 단위를 사용해서 글자 크기를 직접 지정한다. 사용하는 단위는 px(픽셀), pt(포인트), em 등이며 음수값은 사용할 수 없다. 예전에는 절대 크기 단위인 px이나 pt를 많이 사용했지만 모바일 기기까지 고려해야 하는 요즘에는 상대 크기 단위인 em이나 rem을 많이 사용한다. 1em은 16px, 12pt와 같다.
        */

        /*
        CSS에서 사용하는 단위
        em - 부모 요소에서 지정한 글꼴의 대문자 M의 너비를 기준(1em)으로 한 후 비율값을 지정
        rem - 문서 시작 부분(root)에서 지정한 크기를 기준(1rem)으로 한 후 비율값을 지정
        ex - 해당 글꼴의 소문자 x의 높이를 기준(1ex)으로 한 후 비율값을 지정
        px - 모니터의 1픽셀을 기준(1px)으로 한 후 비율값을 지정
        pt - 포인트라고 하며, 일반 문서에서 많이 사용

        뷰포트 단위
        vw(viewport width): 1vw는 뷰포트 너비의 1%와 같다.
        vh(viewport height): 1vh는 뷰포트 높이의 1%와 같다.
        vmin(viewport minimum): 뷰포트의 너비와 높이 중에서 작은 값의 1%와 같다.
        vmax(viewport maximum): 뷰포트의 너비와 높이 중에서 큰 값의 1%와 같다.
        */

        /*
        이탤릭체로 표시
        font-style: italic;
        */

        /*
        글자 굵기
        font-weight: 400;
        속성값 - normal, bold, boler, lighter, 100~900
        */

        /*
        구글 웹 폰트 사용
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&display=swap');

        h1 {
          font-family: 'Nanum Pen Script', cursive;
        }
        */

        /*
        글자색
        color: #000000;
        속성값 - 16진수, rgb(rgba), hsl(hsla), 색상 이름
        */

        /*
        텍스트 정렬
        text-align: center;
        정렬 방법을 지정하지 않을 경우 왼쪽 정렬이 기본, 왼쪽 정렬에서는 오른쪽에 여백이 생기지만 양쪽 정렬에서는 오른쪽에 여백이 생기지 않는다.
        text-align의 속성값
        start - 현재 텍스트 줄의 시작 위치에 맞추어 문단을 정렬
        end - 현재 텍스트 줄의 끝 위치에 맞추어 문단을 정렬
        left - 왼쪽에 맞추어 문단을 정렬
        right - 오른쪽에 맞추어 문단을 정렬
        center - 가운데에 맞추어 문단을 정렬
        justify - 양쪽에 맞추어 문단을 정렬
        match-parent - 부모 요소를 따라 문단을 정렬
        */

        /*
        줄 간격 조절
        line-height: 2.0;
        글자를 세로로 가운데 정렬하려면 line-height의 속성값과 height의 속성값을 똑같이 지정하면 된다.
        */

        /*
        텍스트에 줄을 표시하거나 없애 줌
        text-decoration: underline;
        속성값 - none, underline, overline, line-through
        */

        /*
        텍스트에 그림자 효과를 추가
        text-shadow: none | <가로 거리> <세로 거리> <번짐 정도> <색상>;
        text-shadow의 속성값
        <가로 거리> - 텍스트부터 그림자까지의 가로 거리로 필수 값, 양수값은 글자의 오른쪽, 음수값은 글자의 왼쪽에 그림자를 만든다.
        <세로 거리> - 텍스트부터 그림자까지의 세로 거리로 필수 값, 양수값은 글자의 아래쪽, 음수값은 글자의 위쪽에 그림자를 만든다.
        <번짐 정도> - 그림자가 번지는 정도, 양수값을 사용하면 그림자가 모든 방향으로 퍼져 나가므로 그림자가 크게 표시, 음수값은 그림자가 모든 방향으로 축소되어 보임, 기본값은 0
        <색상> - 그림자 색상을 지정, 한 가지만 지정할 수도 있고, 공백으로 구분해 여러 색상을 지정할 수도 있다. 기본값은 현재 글자색
        */

        /*
        텍스트의 대소 문자를 변환
        text-transform: uppercase;
        이 속성은 한글에는 영향을 미치지 않고 영문자에만 적용됨.
        text-transform의 속성값
        capitalize - 첫 번째 글자를 대문자로 변환
        uppercase - 모든 글자를 대문자로 변환
        lowercase - 모든 글자를 소문자로 변환
        full-width - 가능한 한 모든 문자를 전각 문자로 변환
        */

        /*
        letter-spacing: 0.5em;
        word-spacing: 0.5em;
        letter-spacing 속성은 글자와 글자 사이의 간격을 조절하고 word-spacing 속성은 단어와 단어 사이 간격을 조절하는데, CSS에서는 주로 letter-spacing 속성을 사용해 자간을 조절한다.
        */

        /*
        불릿 모양과 번호 스타일을 지정
        list-style-type: none;
        */

        /*
        불릿 대신 이미지를 사용
        list-style-image: url("이미지 파일 경로");
        */

        /*
        목록을 들여 씀
        list-style-position: inside | outside;
        */

        /*
        목록 속성을 한꺼번에 표시
        list-style: lower-alpha inside;
        */

        /*
        표 제목의 위치를 정해줌
        caption-side: top | bottom;
        */

        /*
        표에 테두리를 그려줌
        표 바깥 테두리와 셀 테두리를 각각 지정
        table {
          border: 1px solid black;
        }
        th, td {
          border: 1px dotted black;
        }
        */

        /*
        셀 사이의 여백 지정
        border-spacing: 수평거리 수직거리;
        */

        /*
        표와 셀 테두리를 합쳐줌
        table {
          border-collapse: collapse | separate;
        }
        */

        /*
        CSS 박스 모델이란 웹 문서의 내용을 박스 형태로 정의하는 방법이다. 박스 모델에는 마진과 패딩, 테두리 등 박스가 여러 겹 들어 있다.
        박스 모델은 블록 레벨 요소인지 인라인 레벨 요소인지에 따라 나열 방법이 달라진다.
        블록 레벨 요소란 태그를 사용해 요소를 삽입했을 때 혼자 한 줄을 차지하는 것을 가리킨다.
        인라인 레벨 요소는 한 줄을 차지하지 않고, 콘텐츠만큼만 영역을 차지하고 나머지 공간에는 다른 요소가 올 수 있다.
        */

        /*
        콘텐츠 영역의 크기를 지정
        width: 300px | 50% | auto;
        height: 100em | 100% | auto;
        */

        /*
        박스 모델의 너비와 높이를 어떻게 결정할 것인가
        box-sizing: border-box;
        box-sizing의 속성값
        border-box - 테두리까지 포함해서 너비값, 높이값을 지정
        content-box - 콘텐츠 영역만 너비값, 높이값을 지정, 기본값
        */

        /*
        박스 모델에 그림자 효과를 줌
        box-shadow: <수평 거리> <수직 거리> <흐림 정도> <번짐 정도> <색상> inset;
        box-shadow의 속성값
        <수평 거리> - 그림자가 가로로 얼마나 떨어져 있는지를 나타낸다. 양수값은 요소의 오른쪽에, 음수값은 요소의 왼쪽에 그림자를 만든다. 필수값이다.
        <수직 거리> - 그림자가 세로로 얼마나 떨어져 있는지를 나타낸다. 양수값은 요소의 아래쪽에, 음수값은 요소의 위쪽에 그림자를 만든다. 필수값이다.
        <흐림 정도> - 이 값을 생략하면 0을 기본값으로 하여 진한 그림자를 표시한다. 이 값이 커질수록 부드러운 그림자를 표시하며, 음수값은 사용할 수 없다.
        <번짐 정도> - 양수값을 사용하면 모든 방향으로 그림자가 퍼져서 박스보다 그림자가 크게 표시된다. 반대로 음수값은 모든 방향으로 그림자가 축소되어 보인다. 기본값은 0
        <색상> - 한 가지만 지정할 수도 있고, 공백으로 구분해서 여러 개의 색상을 지정할 수도 있다. 기본값은 현재 검은색이다.
        inset - 이 키워드를 함께 표시하면 안쪽 그림자로 그린다.
        */

        /*
        박스 모델은 상하좌우 4개의 방향이 있어서 테두리나 마진, 패딩 등을 지정할 때 한꺼번에 똑같이 지정하거나, 모두 다르게 지정할 수도 있다.
        */

        /*
        테두리 스타일 지정
        border-style: solid;
        border-style의 속성값
        none - 테두리가 없다. 기본값
        hidden - 테두리를 감춘다. 표에서 border-collapse: collapse일 경우 다른 테두리도 표시되지 않는다.
        solid - 실선으로 표시
        dotted - 점선으로 표시
        dashed - 짧은 직선으로 표시
        double - 이중선으로 표시, 두 선 사이의 간격이 border-width값이 된다.
        groove, inset, outset, ridge

        만약 테두리 스타일을 4개 방향 모두 다르게 지정하고 싶다면 border-top-style, border-right-style, .. 처럼 border와 style 사이에 상하좌우 방향을 넣고 하이픈(-)으로 연결한다.
        */

        /*
        테두리 두께 지정
        border-width: <크기> | thin | medium | thick;

        border-width: 2px; - 4개 방향 테두리 모두 같은 값이 적용
        border-width: thick thin; - 첫 번째 값인 thick이 위아래(top,bottom) 테두리의 값이 되고, 두 번째 값 thin은 좌우(left,right) 테두리의 값이 됨
        border-width: thick thin thin; - 순서대로 top, right, bottom의 속성값인데 마지막 left 속성값이 빠져 있다. 이때 left 속성값은 마주 보는 right 속성값과 똑같이 적용된다.
        border-width: 10px 5px 5px 10px; - 순서대로 top, right, bottom, left 순으로 적용된다.
        */

        /*
        테두리 색상 지정
        border-color: black;
        */

        /*
        테두리 스타일을 묶어 지정
        border-bottom: 1px solid red;
        border: 1px dotted blue;
        속성값 순서는 상관없다.
        */

        /*
        둥근 테두리를 만들어줌
        border-radius: <크기> | <백분율>;
        border-radius 속성을 사용하면 꼭짓점 부분에 원이 있다고 가정해서 둥글게 처리해줌.

        박스 모델에서 꼭짓점 4개를 모두 다르게 지정하고 싶다면 border-top-left-radius 처럼 border와 radius 사이에 위치를 나타내는 예약어를 넣어 사용한다.

        border-radius 속성을 사용해서 꼭짓점을 타원 형태로 만들 수도 있다. 반지름 대신 타원의 가로 반지름값과 세로 반지름값을 넣어 주는데, 가로 반지름과 세로 반지름 사이에 슬래시(/)를 넣어서 구분한다.
        border-radius: <가로 반지름> / <세로 반지름>;
        특정한 꼭짓점만 타원 형태로 만들겠다면 슬래시 없이 가로 반지름과 세로 반지름을 지정한다.
        border-위치-radius: <가로 반지름> <세로 반지름>;
        */

        /*
        요소 주변의 여백을 설정
        margin: <크기> | <백분율> | auto;
        margin-bottom: 50px;
        margin 속성에서도 속성값을 1개에서 4개까지 지정할 수 있다.

        margin 속성을 사용해 웹 문서의 내용을 화면 중앙에 배치하려면 우선적으로 배치할 요소의 너비값이 정해져 있어야 한다. 그리고 margin-left와 margin-right의 속성값을 auto로 지정한다.
        div {
          width: 600px;
          margin: 20px auto;
        }

        요소를 세로로 배치할 경우에 각 요소의 마진과 마잔이 서로 만나면 마진값이 큰 쪽으로 겹쳐지는데, 이런 현상을 마진 중첩(margin overlap) 또는 마진 상쇄(margin collapse)라고 한다.
        마진 중첩은 아래 마진과 위 마진이 서로 만날 때 큰 마진값으로 합쳐지는 것이고, 오른쪽 마진과 왼쪽 마진이 만날 경우에는 중첩되지 않는다.
        */

        /*
        콘텐츠와 테두리 사이의 여백을 설정
        padding: 20px;
        padding-top: 30px;
        패딩과 마진은 여백이 어느 위치에 있느냐만 다를 뿐 박스 모델에서 패딩을 지정하는 방법은 마진과 거의 같다.
        */

        /*
        배치 방법 결정
        display: block;
        display 속성을 사용하면 블록 레벨 요소와 인라인 레벨 요소를 서로 바꿔서 사용할 수 있다.
        display 속성값
        block - 인라인 레벨 요소를 블록 레벨 요소로 만든다.
        inline - 블록 레벨 요소를 인라인 레벨 요소로 만든다.
        inline-block - 인라인 레벨 요소와 블록 레벨 요소의 속성을 모두 가지고 있으며 마진과 패딩을 지정할 수 있다.
        none - 해당 요소를 화면에 표시하지 않는다.
        */

        /*
        왼쪽이나 오른쪽으로 배치
        float: left;
        float 속성은 웹 요소를 문서 위에 떠 있게 만든다. 여기서 '떠 있다'는 의미는 요소가 왼쪽 구석이나 오른쪽 구석에 배치된다는 것을 말한다.
        float 속성값
        left - 해당 요소를 문서의 왼쪽에 배치
        right - 해당 요소를 문서의 오른쪽에 배치
        none - 좌우 어느 쪽에도 배치하지 않는다. 기본값
        */

        /*
        float 속성을 해제하는 clear 속성
        clear: left;
        clear 속성값
        left - float: left를 해제한다.
        right - float: right를 해제한다.
        both - float: left와 float: right를 해제한다
        */

        /*
        웹 요소의 위치를 정함
        top: 50px; - (기준 위치에서) 요소가 위쪽으로부터 얼마나 떨어져 있는지 지정
        right: 50px; - (기준 위치에서) 요소가 오른쪽으로부터 얼마나 떨어져 있는지 지정
        bottom: 100px; - (기준 위치에서) 요소가 아래쪽으로부터 얼마나 떨어져 있는지 지정
        left: 20px; - (기준 위치에서) 요소가 왼쪽으로부터 얼마나 떨어져 있는지 지정
        */

        /*
        배치 방법을 지정
        position: absolute;
        position 속성값
        static - 문서의 흐름에 맞춰 배치한다. 기본값
        relative - 위치값을 지정할 수 있다는 점을 제외하면 static과 같다.
        absolute - relative값을 사용한 상위 요소를 기준으로 위치를 지정해 배치한다.
        fixed - 브라우저 창을 기준으로 위치를 지정해 배치한다.

        absolute값을 사용할 때는 주의해야 한다. 요소에 position: absolute라고 한 후 위치값을 지정하면 요소 중에서 position: relative를 사용한 요소를 기준으로 위치를 결정한다. 만약 부모 요소 중에 없으면 상위 요소를 찾아보고, 그래도 없다면 더 위의 요소를 찾아본다. 다시 말해 어떤 요소에 position: absolute를 사용하려면 부모 요소에는 position: relative라고 지정해야 원하는 대로 배치할 수 있다.
        */

        /*
        배경색을 지정
        background-color: green;
        background-color 속성값은 상속되지 않는다.
        */

        /*
        배경색의 적용 범위를 조절
        background-clip: content-box;
        background-clip 속성값
        border-box - 박스 모델의 가장 외곽인 테두리까지 적용한다. 기본값
        padding-box - 박스 모델에서 테두리를 뺀 패딩 범위까지 적용한다.
        content-box - 박스 모델에서 내용(콘텐츠) 부분에만 적용한다.
        */

        /*
        웹 요소에 배경 이미지를 넣음
        background-image: url('이미지 파일 경로');
        */

        /*
        배경 이미지의 반복 방법을 지정
        background-repeat: no-repeat;
        background-repeat 속성값
        repeat - 브라우저 화면에 가득 찰 때까지 가로와 세로로 반복한다. 기본값
        repeat-x - 브라우저 화면 너비에 가득 찰 때까지 가로로 반복한다.
        repeat-y - 브라우저 화면 높이에 가득 찰 때까지 세로로 반복한다.
        no-repeat - 한 번만 표시하고 반복하지 않는다.
        */

        /*
        배경 이미지의 위치를 조절
        background-position: <수평 위치> <수직 위치>;
        <수평 위치> - left | center | right | <백분율> | <길이 값>
        <수직 위치> - top | center | bottom | <백분율> | <길이 값>
        속성값을 2개로 지정한다면 첫 번째 값은 수평 위치의 값이 되고 두 번째 값은 수직 위치의 값이 된다. 속성값을 하나만 지정한다면 웹 브라우저에서는 지정한 값을 수평 위치값으로 간주하고, 수직 위치값은 50%나 center로 간주한다.
        */

        /*
        배경 이미지의 적용 범위를 조절
        background-origin: border-box;
        background-origin 속성값
        content-box - 박스 모델에서 내용 부분에만 배경 이미지를 표시한다. 기본값
        padding-box - 박스 모델에서 패딩까지 배경 이미지를 표시한다.
        border-box - 박스 모델에서 테두리까지 배경 이미지를 표시한다.
        */

        /*
        배경 이미지를 고정
        background-attachment: fixed;
        background-attachment 속성값
        scroll - 화면을 스크롤하면 배경 이미지도 스크롤된다. 기본값
        fixed - 화면을 스크롤하면 배경 이미지는 고정되고 내용만 스크롤된다.
        */

        /*
        background 속성 하나로 배경 이미지 제어
        background: url('이미지 파일 경로') no-repeat center bottom fixed;
        속성값이 다르므로 입력 순서는 상관없다.
        */

        /*
        배경 이미지 크기를 조절
        background-size: cover;
        background-size 속성값
        auto - 원래 배경 이미지 크기만큼 표시한다. 기본값
        contain - 요소 안에 배경 이미지가 다 들어오도록 이미지를 확대,축소한다.
        cover - 배경 이미지로 요소를 모두 덮도록 이미지를 확대,축소한다.
        <크기> - 이미지의 너비와 높이를 지정한다. 값이 하나만 주어질 경우 너비값으로 인식하며, 높이는 원래 이미지의 너비와 높이 비율에 따라 자동 계산한다.
        <백분율> - 배경 이미지가 들어갈 요소의 크기를 기준으로 값을 백분율로 지정하고 그 크기에 맞도록 배경 이미지를 확대,축소한다.
        */

        /*
        선형 그러데이션
        선형 그러데이션이란 색상이 수직, 수평 또는 대각선 방향으로 일정하게 변하는 것을 말한다. 이것을 만들어 주는 함수는 linear-gradient인데 색상이 어느 방향으로 바뀌는지 그리고 어떤 색상으로 바뀌는지 알려 주어야 한다.

        background: linear-gradient(to <방향> 또는 <각도>, <색상 중지점>, ...);
        to 다음에는 방향을 나타내는 예약어를 최대 2개까지 사용할 수 있다. 이때 예약어는 수평 방향을 나타내는 left와 right, 수직 방향을 나타내는 top과 bottom을 사용한다. 예약어 2개를 사용할 경우 순서는 상관없다. 선형 그러데이션의 위치나 각도 옵션을 생략하면 to bottom으로 인식한다.
        background: linear-gradient(to right bottom, blue, white);
        background: linear-gradient(45deg, red, white);
        background: linear-gradient(to bottom, blue, white 30%, blue);
        */

        /*
        원형 그러데이션
        선형 그러데이션이 직선 형태로 색상이 바뀌는 거라면, 원형 그러데이션은 원 또는 타원의 중심에서부터 동심원을 그리며 바깥 방향으로 색상이 바뀐다.

        background: radial-gradient(<모양> <크기> at <위치>, <색상 중지점>, ...);
        원형 그러데이션에서 만들어지는 모양은 원형(circle)과 타원형(ellipse)이다. 모양을 따로 지정하지 않으면 타원형으로 인식한다.
        원형 그러데이션을 지정할 때 원의 크기도 정할 수 있다. 원의 모양(circle 또는 ellipse)과 크기를 나타내는 키워드값을 함께 쓰면 된다.

        크기 속성값
        closest-side - 그러데이션 가장자리가 그러데이션 중심에서 가장 가까운 요소의 측면에 닿을 때까지 그린다.
        closest-corner - 그러데이션 가장자리가 중심에서 가장 가까운 요소의 코너에 닿도록 그린다.
        farthest-side - 그러데이션 가장자리가 그러데이션 중심에서 가장 멀리 떨어져 있는 요소의 측면에 닿을 때까지 그린다.
        farthest-corner - 그러데이션 가장자리가 그러데이션 중심에서 가장 멀리 떨어져 있는 요소의 코너에 닿도록 그린다. 기본값

        at 키워드와 함께 위치를 지정하면 그러데이션이 시작하는 원의 중심을 다르게 나타낼 수 있다.
        사용할 수 있는 위치 속성값은 키워드(left, center, right 중 하나 또는 top, center, bottom 중 하나) 또는 30%, 20% 같은 백분율이다. 속성값을 생략하면 가로와 세로 모두 중앙인 center로 인식한다.
        background: radial-gradient(circle at 20% 20%, white, blue);
        background: radial-gradient(yellow, white 10%, orange 60%);
        */

        /*
        선형 그러데이션과 원형 그러데이션은 반복해서 패턴을 만들 수 있다. 선형 그러데이션을 반복할 때는 repeating-linear-gradient를 사용하고, 원형 그러데이션을 반복할 때는 repeating-radial-gradient를 사용한다.

        background: repeating-linear-gradient(yellow, red 20px);
        background: repeating-radial-gradient(circle, white, #ccc 10%);

        background: repeating-linear-gradient(yellow, yellow 20px, red 20px, red 40px);
        background: repeating-radial-gradient(circle, white, white 10%, #ccc 10%, #ccc 20%);
        */

        /*
        transform과 변형 함수
        CSS에서 변형을 적용하려면 transform 속성과 변형 함수 이름을 함께 작성해야 한다.
        transform: 함수;
        */

        /*
        웹 요소를 이동
        transform: translate(tx, ty); - x축으로 tx만큼, y축으로 ty만큼 이동, tx와 ty 2가지 값을 사용하지만 ty값이 주어지지 않으면 0으로 간주
        transform: translate3d(tx, ty, tz); - x축으로 tx만큼, y축으로 ty만큼, z축(앞뒤)으로 tz만큼 이동
        transform: translateX(tx);
        transform: translateY(ty);
        transform: translateZ(tz);
        */

        /*
        웹 요소를 확대,축소
        transform: scale(sx, sy); - x축으로 sx만큼, y축으로 sy만큼 확대 or 축소한다. 값이 하나뿐일 경우에는 x, y에 같은 값을 적용한다. 예를 들어 scale(2)는 scale(2, 2)와 같은 함수이며, 요소를 2배로 확대한다. 괄호 안의 값(sx, sy, sz)이 1보다 크면 확대되고 1보다 작으면 축소된다.
        transform: scale3d(sx, sy, sz);
        transform: scaleX(sx);
        transform: scaleY(sy);
        transform: scaleZ(sz);
        */

        /*
        웹 요소를 회전
        2차원 회전
        transform: rotate(각도);

        3차원 회전
        transform: rotate(rx, ry, 각도);
        transform: rotate3d(rx, ry, rz, 각도);
        transform: rotateX(각도);
        transform: rotateY(각도);
        transform: rotateZ(각도);
        이때 perspective 속성을 함께 사용해서 원근감을 추가해 주면 회전 형태를 입체적으로 표현할 수 있다. perspective 속성은 3차원 변형에서 사용하는데, 원래 있던 위치에서 사용자가 있는 방향이나 혹은 반대 방향으로 잡아당기거나 밀어내어 원근감을 표현한다. perspective 속성에서 사용하는 값은 0보다 커야 하며, 원래 있던 위치에서 사용자가 있는 쪽으로 얼마나 이동하는지를 픽셀 크기로 나타낸다. 값이 클수록 사용자로부터 멀어진다. 이때 주의할 점은 perspective 속성은 변형하는 요소가 아니라 변형하는 요소의 부모 요소에 정의해야 한다는 것이다.
        */

        /*
        웹 요소를 비틀어 왜곡
        transform: skew(x각도, y각도); - 첫 번째 값은 x축을 기준으로 비트는 각도이고, 두 번째 값은 y축을 기준으로 비트는 각도이다. 두 번째 값이 주어지지 않으면 y축 각도를 0으로 간주한다.
        transform: skewX(각도);
        transform: skewY(각도);
        */

        /* 웹 요소의 스타일 속성이 시간에 따라 바뀌는 것을 트랜지션이라고 한다. */

        /*
        트랜지션의 대상을 지정
        transition-property: all | none | <속성 이름>;
        transition-property 속성값
        all - all값을 사용하거나 transition-property를 생략할 경우 요소의 모든 속성이 트랜지션 대상이 된다. 기본값
        none - 트랜지션을 하는 동안 아무 속성도 바뀌지 않는다.
        속성 이름 - 트랜지션 효과를 적용할 속성을 지정한다. 예를 들어 배경색만 바꿀 것인지, width값을 바꿀 것인지 원하는 대상만 골라 지정할 수 있다. 속성이 여럿일 경우 쉼표(,)로 구분하여 나열한다.
        */

        /*
        트랜지션의 진행 시간을 지정
        transition-duration: <시간>;
        지정할 수 있는 시간 단위는 초 또는 밀리초이며, 트랜지션의 대상 속성이 여러 개라면 진행 시간도 쉼표(,)로 구분해서 여러 개를 지정할 수 있다. 음수값을 지정하면 0으로 간주한다.
        */

        /*
        트랜지션의 속도 곡선을 지정
        transition-timing-function: ease;
        transition-timing-function 속성값
        ease - 처음에는 천천히 시작하고 점점 빨라지다가 마지막엔 천천히 끝낸다. 기본값
        linear - 시작부터 끝까지 똑같은 속도로 진행한다.
        ease-in - 느리게 시작한다.
        ease-out - 느리게 끝낸다.
        ease-in-out - 느리게 시작하고 느리게 끝낸다.
        cubic-bezier(n, n, n, n) - 베지에 함수를 정의해서 사용한다. 이때 n값은 0 ~ 1 사이만 사용할 수 있다.
        */

        /*
        트랜지션의 지연 시간을 지정
        transition-delay: <시간>;
        이 속성을 사용하면 지정한 시간만큼 기다렸다가 트랜지션이 시작된다. 지정할 수 있는 시간 단위는 초 또는 밀리초이며, 기본값은 0이다.
        */

        /*
        트랜지션의 속성을 한꺼번에 표기
        transition: <transition-property값> | <transition-duration값> | <transition-timing-function값> | <transition-delay값>;
        속성값을 작성하는 순서는 상관이 없다. 다만 시간값을 사용하는 속성이 2개(진행 시간, 지연 시간)이므로 시간값이 2개 있다면 앞에 오는 시간값을 transition-duration 속성으로, 뒤에 오는 시간값은 transition-delay 속성으로 간주한다.
        */

        /*
        애니메이션
        CSS3의 animation 속성을 사용하면 자바스크립트를 사용하지 않고도 웹 요소에 애니메이션을 추가할 수 있다. animation 속성은 특정 지점에서 스타일을 바꾸면서 애니메이션을 만드는데, 이렇게 애니메이션 중간에 스타일이 바뀌는 지점을 키프레임(keyframe)이라고 한다.
        키프레임은 @keyframes 속성으로 정의하고, animation 속성과 그 하위 속성을 이용해서 애니메이션의 실행 시간이나 반복 여부 등을 지정한다.
        */

        /*
        애니메이션의 지점과 이름을 설정 (애니메이션 정의)
        @keyframes <이름> {
          <선택자> { <스타일> }
        }
        @keyframes 속성에서 사용하는 선택자는 스타일 속성값이 바뀌는 지점을 가리킨다. 예를 들어 애니메이션의 중간 지점을 추가하려면 시작 위치를 0%, 끝 위치를 100%로 놓고 50% 위치에 키프레임을 추가하면 된다. 시작과 끝 위치만 사용하려면 0%, 100%와 같은 값 대신 from과 to라는 키워드를 사용해도 된다.

        사용 예시
        @keyframes shape {
          from {
            border: 1px solid transparent;
          }
          to {
            border: 1px solid black;
            border-radius: 50%;
          }
        }

        #box {
          background-color: green;
          border: 1px solid transparent;
          animation-name: shape;
          animation-duration: 3s;
        }
        */

        /*
        정의한 애니메이션 사용
        animation-name: <키프레임 이름> | none;
        */

        /*
        애니메이션의 실행 시간을 지정
        animation-duration: <시간>;
        지정할 수 있는 시간 단위는 초(s) 또는 밀리초(ms), 기본값은 0이므로 animation-duration 속성값을 정하지 않으면 애니메이션은 실행되지 않는다.
        */

        /*
        애니메이션의 방향을 지정
        animation-direction: normal;
        animation-direction 속성값
        normal - 애니메이션을 from에서 to로 진행한다. 기본값
        reverse - 애니메이션을 to에서 from으로, 원래 방향과는 반대로 진행한다.
        alternate - 홀수 번째는 normal로, 짝수 번째는 reverse로 진행한다.
        alternate-reverse - 홀수 번째는 reverse로, 짝수 번째는 normal로 진행한다.
        */

        /*
        애니메이션의 반복 횟수를 지정
        animation-iteration-count: <숫자> | infinite;
        animation-iteration-count 속성값
        <숫자> - 애니메이션의 반복 횟수를 정한다.
        infinite - 애니메이션을 무한 반복한다.
        */

        /*
        애니메이션의 속도 곡선을 지정
        animation-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(n, n, n, n);
        */

        /*
        애니메이션의 속성을 한꺼번에 표기
        animation: <animation-name> | <animation-duration> | <animation-timing-function> | <animation-delay> | <animation-iteration-count> | <animation-direction>;
        주의할 점은 animation 속성을 사용할 때 animation-duration 속성값을 반드시 표기해야 한다는 것이다. 애니메이션 실행 시간을 지정하지 않으면 기본값으로 0이 적용되어 애니메이션 효과를 볼 수 없기 때문이다.

        사용 예시
        @keyframes rotate {
          from {
            transform: perspective(120px) rotateX(0deg) rotateY(0deg);
          }
          50% {
            transform: perspective(120px) rotateX(-180deg) rotateY(0deg);
          }
          to {
            transform: perspective(120px) rotateX(-180deg) rotateY(-180deg);
          }
        }

        @keyframes background {
          from {
            background-color: red;
          }
          50% {
            background-color: green;
          }
          to {
            background-color: blue;
          }
        }

        #box {
          width: 100px;
          height: 100px;
          margin: 60px auto;
          animation: rotate 1.5s infinite, background 1.5s infinite alternate;
        }
        */

        /*
        사용자가 어떤 미디어를 사용하는가에 따라 사이트의 형태가 바뀌도록 CSS를 작성하는 방법을 미디어 쿼리라고 한다.
        */

        /*
        미디어 쿼리의 기본형
        @media [only | not] 미디어 유형 [and 조건] * [and 조건] {
        }
        only - 미디어 쿼리를 지원하지 않는 웹 브라우저에서는 미디어 쿼리를 무시하고 실행하지 않는다.
        not - not 다음에 지정하는 미디어 유형을 제외한다. 예를 들어 not tv라고 지정하면 TV를 제외한 미디어 유형에만 적용한다.
        and - 조건을 여러 개 연결해서 추가할 수 있다.

        사용 예시
        @media screen and (min-width: 700px) and (max-width: 1400px) {
          background-color: blue;
        }
        @media screen and (min-device-width: 375px) and (min-device-height: 812px) {
          color: blue;
        }
        */

        /*
        미디어 쿼리는 미디어별로 적용할 CSS를 따로 작성하므로 @media 속성 다음에 미디어 유형을 알려 줘야 한다.
        @media 속성의 미디어 유형
        all - 모든 미디어 유형에서 사용할 CSS를 정의한다.
        print - 인쇄 장치에서 사용할 CSS를 정의한다.
        screen - 컴퓨터 스크린에서 사용할 CSS를 정의한다. 스마트폰의 스크린도 포함된다.
        tv - 음성과 영상이 동시에 출력되는 TV에서 사용할 CSS를 정의한다.
        그 외에 aural, braille, handheld 등이 있다.
        */

        /*
        미디어 쿼리에서 orientation 속성을 사용하면 기기의 방향을 확인할 수 있고, 그에 따라서 웹 사이트의 레이아웃을 바꿀 수 있다. orientation 속성값으로는 portrait와 landscape가 있다. 가로 모드는 landscape이고, 세로 모드는 portrait이며, 기본값은 landscape이다.

        사용 예시
        @media screen and (min-device-width: 812px) and (orientation: landscape) {
        }

        모바일 기기의 뷰포트 크기값이 정리되어 있는 사이트 : https://yesviz.com/devices.php
        */
        
        /*
        미디어 쿼리 적용하기
        미디어 쿼리를 웹 문서에 적용하는 방법은 크게 '외부 CSS 파일로 연결하는 방법'과 '웹 문서에 직접 정의하는 방법'이 있다.
        */
        
        /*
        외부 CSS 파일로 연결하는 방법 - 이 방법은 각 조건별로 CSS 파일을 따로 저장한 뒤 <link> 태그나 @import 문을 사용해서 연결한다.

        기본형 - <link rel="stylesheet" media="미디어 쿼리 조건" href="css 파일 경로">
        기본형의 의미는 미디어 쿼리 조건이 맞다면 지정한 CSS 파일을 가져와서 적용하라는 것이다. 속성의 순서는 상관없다.

        사용 예시
        <link rel="stylesheet" media="print" href="css/print.css">

        기본형 - @import url(css 파일 경로) 미디어 쿼리 조건;

        사용 예시
        @import url("css/tablet.css") only screen and (min-width: 321px) and (max-width: 768px);

        <link> 태그와 @import 문은 모두 외부에서 CSS 파일을 가져와 사용하는 방법이다. CSS 파일이 한두개밖에 없다면 속도나 처리 면에서는 큰 차이가 없다. 그런데 인터넷 익스플로러의 경우 @import 문과 자바스크립트가 함께 있을 경우 자바스크립트를 먼저 내려받은 후에 @import 문에 있는 CSS를 다운로드 한다. 그래서 자바스크립트에서 스타일과 관련된 정보를 처리해야 할 경우 오류가 날 수도 있다. 그러므로 CSS 파일이 많고 규모가 큰 사이트를 개발한다면 @import 문보다 <link> 태그를 사용하는게 좋다.
        */

        /*         
        웹 문서에 직접 정의하는 방법 - 2가지

        1. <style> 태그 안에서 media 속성을 사용하여 조건을 지정하고, 그 조건에 맞는 스타일 규칙을 정의
        
        사용 예시
        <style media="screen and (max-width: 320px)">
          body {
            background-color: red;
          }
        </style>

        2. 스타일을 선언할 때 @media 문을 사용해 각 조건별로 스타일을 지정해 놓고 조건에 따라 스타일을 선택해서 적용하기

        사용 예시
        <style>
          @media screen and (max-width: 320px) {
            body {
              background-color: red;
            }
          }
          @media screen and (min-width: 321px) {
            body {
              background-color: blue;
            }
          }
        </style>
        */
      }
    </style>
  </head>
  <body>
    <!-- 
    선택자 {
      속성1 : 속성값;
      속성2 : 속성값;
    }
    맨 앞의 선택자는 스타일을 어느 태그에 적용할 것인지 알려 주는 것이고, 중괄호({}) 사이에는 스타일 정보를 넣는다. 속성과 값이 하나의 쌍으로 이루어진 것을 스타일 규칙이라고 하며, 세미콜론(;)으로 구분해서 스타일 규칙을 여러 개 지정할 수 있다.
    -->

    <!-- 
    CSS 소스 경량화
    CSS 소스에 주석을 넣거나 줄 바꿈하는 것은 웹 사이트 작성자가 알아보기 쉽도록 하는 것일 뿐 웹 브라우저에는 아무 의미가 없다. 웹 브라우저에서 CSS 소스를 읽을 때는 선택자와 속성, 그리고 속성값만 의미가 있다. CSS 소스는 네트워크를 이용해 파일로 내려받으므로 되도록이면 파일 크기가 작은 것이 좋다. 그래서 CSS 소스가 길면 주석이나 줄 바꿈, 공백 등을 제거하고 꼭 필요한 정보만 남겨서 파일을 작게 만들어 사용한다. 이것을 CSS 소스 경량화(minify)라고 한다. 인터넷에서 'css minify' 또는 'css compress'를 검색하면 CSS 소스 파일의 크기를 줄여 주는 다양한 툴을 찾을 수 있다.
    -->

    <!-- 
    스타일 시트
    웹 문서 안에서는 스타일 규칙을 여러 개 사용한다. 이런 스타일 규칙을 한눈에 확인하고 필요할 때마다 수정하기도 쉽도록 한군데 묶어 놓은 것을 스타일 시트라고 한다. 스타일 시트는 크게 웹 브라우저에 기본으로 만들어져 있는 브라우저 기본 스타일과 사이트 제작자가 만드는 사용자 스타일로 나눌 수 있다. 사용자 스타일은 다시 인라인 스타일과 내부 스타일 시트, 외부 스타일 시트로 나뉜다.
    -->

    <!-- 
    기본 선택자
    * : 전체 선택자, 웹 브라우저의 기본 스타일을 초기화할 때 자주 사용
    태그명 : 타입 선택자(= 태그 선택자, 요소 선택자), 특정 태그를 사용한 모든 요소에 스타일을 적용
    .클래스명 : 클래스 선택자, 클래스 선택자를 사용해 만든 스타일을 클래스 스타일이라고 하는데, 이미 만들어 둔 클래스 스타일을 적용할 때는 태그 안에 class="클래스명"처럼 class 속성을 사용해서 지정한다.
    #아이디명 : id 선택자, 클래스 스타일은 문서에서 여러 번 적용할 수 있는 반면, id 스타일은 문서에서 한 번만 적용할 수 있다.
    선택자1, 선택자2 : 그룹 선택자

    고급 선택자

    연결 선택자(= 조합 선택자)
    상위요소 하위요소 : 하위 선택자(= 자손 선택자)
    부모요소 > 자식요소 : 자식 선택자
    요소1 + 요소2 : 인접 형제 선택자, 형제 요소 중에서 첫 번째 동생 요소만 선택, 요소1과 요소2는 같은 레벨이면서 요소1 이후 가장 먼저 오는 요소2를 선택
    요소1 ~ 요소2 : 형제 선택자, 형제 요소의 스타일을 정의하는데 인접 형제 선택자와 달리 모든 형제(동생) 요소에 적용

    속성 선택자
    a[href] : [속성] 선택자, 특정 속성이 있는 요소를 선택
    a[target="_blank"] : [속성 = 속성값] 선택자, 특정 속성과 속성값이 있는 요소를 선택
    [class ~= button] : [속성 ~= 속성값] 선택자, 여러 속성값 중에서 해당 속성값이 포함된 요소를 선택, button 값과 정확하게 일치하는 요소를 선택, 만약 flat-button이나 buttons처럼 button 외에 다른 글자가 속성값에 포함되어 있으면 선택하지 않는다.
    a[title |= us] : [속성 |= 속성값] 선택자, 특정 속성과 속성값이 있는 요소를 선택, 지정한 값과 정확하게 일치하거나 지정한 값을 포함해서 하이픈(-)으로 연결된 단어도 선택, title 속성값에 us가 있거나 us-로 연결된 속성값이 있는 a 요소를 선택
    a[title ^= eng] : [속성 ^= 속성값] 선택자, 속성값이 정확하게 일치하지 않더라도 지정한 속성값으로 시작하는 요소를 선택, title 속성값이 eng로 시작하는 a 요소를 선택
    a[href $= xls] : [속성 $= 속성값] 선택자, 지정한 속성값으로 끝나는 요소를 선택, href 속성값이 xls로 끝나는 a 요소를 선택
    a[href *= w3] : [속성 *= 속성값] 선택자, 속성값이 어느 위치에 있든지 지정한 속성값이 포함되어 있다면 해당 요소를 선택, href 속성값 중에 w3가 포함된 a 요소를 선택

    가상 클래스 선택자
    :link - 웹 문서의 링크 중에서 사용자가 아직 방문하지 않은 링크에 스타일을 적용
    :visited - 웹 문서의 링크 중에서 한 번 이상 방문한 링크에 스타일을 적용
    :hover - 웹 요소 위로 마우스 포인터를 올려놓을 때 스타일을 적용
    :active - 웹 요소의 링크나 이미지 등을 활성화했을 때, 즉 클릭했을 때 스타일을 적용
    :focus - 웹 요소에 초점이 맞추어졌을 때 스타일을 적용

    link, visited, hover, active 가상 클래스 선택자는 메뉴 링크에서 자주 사용하는데, link -> visited -> hover -> active 순서로 정의해야 한다. 이 순서가 바뀌면 스타일을 정의하더라도 제대로 적용되지 않는다. LoVe HAte로 외우면 쉽다.

    :target - 앵커로 연결된 부분, 즉 앵커의 목적지가 되는 부분의 스타일을 적용
    사용 예시
    #intro:target {
      background-color: blue;
      color: white;
    }
    <a href="#intro">이용 안내</a>
    <div id="intro">이용 안내~~</div>

    :enabled - 해당 요소가 사용할 수 있는 상태일 때 스타일을 적용
    :disabled - 해당 요소가 사용할 수 없는 상태일 때 스타일을 적용, 예를 들어 텍스트 영역 필드(textarea)를 사용해 회원 약관을 보여 줄 때는 사용자가 입력할 수 없도록 disabled 속성을 지정해야 한다. 이때 :disabled를 사용하면 이런 텍스트 영역 필드의 스타일을 쉽게 적용할 수 있다.

    :checked - 폼의 라디오 박스나 체크 박스에서 선택된 항목에는 checked라는 속성이 추가된다. 이렇게 checked 속성이 있는 요소의 스타일을 지정할 때 :checked를 사용하면 편리하다.

    :not - 괄호 안에 있는 요소를 제외하고 스타일을 적용
    사용 예시
    input:not([type=radio]) {
      border: 1px solid #ccc;
      padding: 5px;
    }

    구조 가상 클래스 선택자
    :only-child - 부모 안에 자식 요소가 하나뿐일 때 자식 요소를 선택
    A:only-type-of - 부모 안에 A 요소가 하나뿐일 때 선택
    :first-child - 부모 안에 있는 모든 자식 요소 중에서 첫 번째 자식 요소를 선택
    :last-child - 부모 안에 있는 모든 자식 요소 중에서 마지막 자식 요소를 선택
    A:first-of-type - 부모 안에 있는 A 요소 중에서 첫 번째 A 요소를 선택
    A:last-of-type - 부모 안에 있는 A 요소 중에서 마지막 A 요소를 선택
    :nth-child(n) - 부모 안에 있는 모든 자식 요소 중에서 n번째 자식 요소를 선택
    :nth-last-child(n) - 부모 안에 있는 모든 자식 요소 중에서 끝에서 n번째 자식 요소를 선택
    A:nth-of-type(n) - 부모 안에 있는 A 요소 중에서 n번째 A 요소를 선택
    A:nth-last-of-type(n) - 부모 안에 있는 A 요소 중에서 끝에서 n번째 A 요소를 선택

    위치를 지정할 때 :nth-child(3) 선택자처럼 위치를 정확히 알려 줄 수도 있지만 1, 3, 5번째처럼 위치가 계속 바뀐다면 반복된 규칙을 찾아내서 an+b처럼 수식을 사용할 수도 있다. 이때 n값은 0부터 시작한다. 또는 홀수 번째에 스타일을 줄 때는 :nth-child(odd), 짝수 번째에 스타일을 줄 때는 :nth-child(even)을 사용할 수 있다.

    사용 예시
    홀수 번째 행만 스타일 적용
    table tr:nth-of-type(2n+1) {
      background-color: blue;
      color: white;
    }

    가상 요소
    가상 클래스가 웹 문서의 여러 요소 중에서 원하는 요소를 선택한다면, 가상 요소는 문서 안의 특정 부분에 스타일을 지정하기 위해 가상으로 요소를 만들어 추가한다. 가상 요소를 만들어 사용하는 이유는 특별히 화면에 보이는 부분을 꾸밀 때 불필요한 태그를 사용하지 않도록 하기 위한 것이다. 가상 요소는 가상 클래스와 구별하도록 가상 요소 이름 앞에 콜론 2개(::)를 붙여서 표시한다.

    ::first-line 가상 요소와 ::first-letter 가상 요소를 사용하면 지정한 요소의 첫 번째 줄이나 첫 번째 글자에 스타일을 적용할 수 있다. ::first-letter 가상 요소는 해당 요소의 첫 번째 글자를 가리키는데, 첫 번째 글자는 반드시 첫 번째 줄에 있어야 한다. 만약 <p> 태그 안에 <br> 태그가 있어서 첫 번째 글자가 첫 번째 줄에 없을 경우에는 적용할 수 없다.

    ::before 가상 요소와 ::after 가상 요소를 사용하면 지정한 요소의 내용 앞뒤에 스타일을 넣을 수 있다. 이 가상 요소를 사용하면 요소의 앞뒤에 텍스트나 이미지 등을 추가할 수 있다.

    사용 예시
    li.new::after {
      content: "NEW!!";
      font-size: x-small;
      padding: 2px 4px;
      margin: 0 10px;
      border-radius: 2px;
      background: red;
      color: white;
    }

    <ul>
      <li class="new">제품 A</li>
      <li>제품 B</li>
    </ul>
    -->

    <!-- 
    캐스케이딩의 의미
    CSS에서 'C'는 캐스케이딩(cascading)의 줄임말이며 스타일 시트에서는 우선순위가 위에서 아래, 즉 계단식으로 적용된다는 의미로 사용한다. 다시 말해 CSS는 우선순위가 있는 스타일 시트 정도로 해석할 수 있다. 그래서 CSS에서는 웹 요소에 둘 이상의 스타일을 적용할 때 우선순위에 따라 적용할 스타일을 결정한다. 캐스케이딩은 스타일끼리 충돌하지 않도록 막아 주는 중요한 개념이다. 스타일이 충돌하지 않게 하는 방법으로 2가지 방법이 있다.
    1. 스타일 우선순위 : 스타일 규칙의 중요도와 적용 범위에 따라 우선순위가 결정되고, 그 우선순위에 따라 위에서 아래로 스타일을 적용한다.
    2. 스타일 상속 : 태그의 포함 관계에 따라 부모 요소의 스타일을 자식 요소로, 위에서 아래로 전달한다.
    -->
  </body>
</html>
